# [프로젝트명] - 설계 문서

## 1. 시스템 아키텍처 개요
*   전체 시스템 구성도: 본 프로젝트는 웹 기반의 3D 모션 적용 플랫폼으로, 프론트엔드, 백엔드, 데이터베이스, 오브젝트 스토리지, 그리고 3D 모델/모션 처리 모듈로 구성됩니다.
*   주요 컴포넌트 및 역할:
    *   **프론트엔드:** 사용자 인터페이스(UI)를 제공하고, 백엔드 API와 통신하며, 3D 뷰어를 통해 모델 및 모션 렌더링을 담당합니다.
    *   **백엔드:** 사용자 인증/인가, 3D 모델/모션 메타데이터 관리, 모션 적용 로직 처리, 파일 업로드/다운로드 관리, 프론트엔드 API 제공을 담당합니다.
    *   **데이터베이스:** 사용자 정보, 3D 모델 및 모션의 메타데이터, 프로젝트 정보 등 구조화된 데이터를 저장하고 관리합니다.
    *   **오브젝트 스토리지:** 대용량 3D 모델 및 모션 파일과 같은 바이너리 데이터를 저장하고 관리합니다.
    *   **3D 모델/모션 처리 모듈:** 백엔드에서 3D 모델 파싱, 모션 적용, 변환 등 복잡한 3D 관련 처리를 수행합니다.

## 2. 기술 스택 상세
*   **프론트엔드:**
    *   주요 프레임워크/라이브러리: React (UI), Three.js (3D 렌더링), React-Three-Fiber (React와 Three.js 연동)
    *   **모션 캡처/포즈 추정:** Google MediaPipe Pose 또는 TensorFlow.js PoseNet/MoveNet (웹캠/휴대폰 카메라 영상 분석)
    *   빌드 도구: Vite
    *   상태 관리: React Context API (전역 상태), React Query (서버 상태 캐싱)
    *   스타일링: Tailwind CSS
    *   언어: TypeScript
*   **백엔드:**
    *   주요 프레임워크: Spring Boot
    *   언어: Java
    *   데이터베이스 연동: Spring Data JPA
    *   인증/인가: Spring Security, JWT
    *   **3D 처리:** Assimp-Java (3D 모델 파싱 및 변환), 커스텀 모션 리타겟팅/최적화 로직 (Java 또는 Python 연동)
*   **데이터베이스:**
    *   종류: MySQL
    *   주요 테이블 및 관계 (간략히): User, Model, Motion, Project 엔티티 간의 관계 설정.

## 3. 핵심 기능별 기술 활용 방안

### 3.1. 3D 모델 관리
*   **기술:** Three.js (GLTFLoader, OBJLoader 등), WebGL
*   **활용 방안:**
    *   **업로드:** 클라이언트 측에서 GLB, FBX, OBJ 등 다양한 3D 모델 파일을 파싱하여 유효성 검사 후 서버로 전송.
    *   **저장:** 서버에서 업로드된 모델 파일을 저장하고, 메타데이터(모델명, 형식, 크기 등)를 데이터베이스에 기록. 썸네일 자동 생성 기능 구현.
    *   **조회/편집:** Three.js를 활용한 웹 기반 3D 뷰어에서 모델을 렌더링하고, 모델 정보 편집 기능 제공.

### 3.2. 모션 라이브러리
*   **기술:** 백엔드 데이터베이스 (MySQL), 검색 엔진 (예: Elasticsearch 또는 DB 인덱싱), 프론트엔드 (React Query, Three.js)
*   **활용 방안:**
    *   **데이터베이스:** 모션 데이터(파일 경로, 메타데이터, 태그, 카테고리 등)를 저장.
    *   **검색/필터링:** 백엔드에서 키워드 검색 및 필터링 API 제공. 프론트엔드에서 React Query를 활용하여 비동기적으로 모션 목록을 탐색.
    *   **미리보기:** Three.js 기반 3D 뷰어에서 모션 파일을 로드하여 실시간으로 동작 미리보기.

### 3.3. 지능형 모션 적용
*   **기술:**
    *   **모션 캡처 (프론트엔드):** WebRTC API (카메라 접근), Google MediaPipe Pose 또는 TensorFlow.js PoseNet/MoveNet (실시간 인체 포즈 추정).
    *   **모션 데이터 전송:** WebSocket (실시간 포즈 데이터 스트리밍).
    *   **3D 데이터 변환 (백엔드):** Assimp-Java (3D 모델 파싱, 뼈대 추출), 커스텀 로직 (2D/3D 포즈 데이터 -> 3D 모션 데이터 변환).
    *   **모션 리타겟팅 (백엔드):** 커스텀 알고리즘 (소스 스켈레톤 -> 타겟 스켈레톤 모션 적용), 3D 수학 라이브러리.
*   **활용 방안:**
    *   **1단계: 사용자 모션 녹화 및 포즈 추정 (프론트엔드)**
        1.  사용자 웹캠/휴대폰 카메라 영상 스트림 획득 (WebRTC).
        2.  획득된 영상에서 실시간으로 인체 관절(키포인트) 위치 추정 (MediaPipe Pose/TensorFlow.js).
        3.  추정된 관절 데이터를 정제하여 백엔드로 WebSocket을 통해 스트리밍.
        *   **고민 사항:** 웹 환경에서의 실시간 포즈 추정 성능, 다양한 카메라 환경 및 사용자 자세에 대한 정확도, 데이터 전송 효율성.
    *   **2단계: 모션 데이터 변환 및 저장 (백엔드)**
        1.  프론트엔드로부터 스트리밍된 관절 데이터를 수신.
        2.  수신된 관절 데이터를 3D 스켈레톤 애니메이션 데이터(예: BVH, FBX 애니메이션 트랙)로 변환.
        3.  변환된 모션 데이터를 오브젝트 스토리지에 저장하고, 메타데이터를 DB에 기록.
        *   **고민 사항:** 2D/3D 포즈 데이터에서 3D 모션 데이터로의 정확한 변환 알고리즘, 데이터 형식 표준화, 대용량 데이터 처리.
    *   **3단계: 3D 모델 분석 및 모션 리타겟팅 (백엔드)**
        1.  사용자가 업로드한 3D 모델 파일 파싱 (Assimp-Java)하여 모델의 뼈대(Skeleton) 구조 및 계층 정보 추출.
        2.  변환된 사용자 모션 데이터(소스 스켈레톤)를 대상 3D 모델의 뼈대(타겟 스켈레톤)에 맞게 리타겟팅.
        3.  **리타겟팅 로직:** 소스 스켈레톤과 타겟 스켈레톤의 관절 매핑, 비율 조정, 관절 제한 고려, IK(Inverse Kinematics) 또는 FK(Forward Kinematics) 기반의 포즈 계산.
        4.  모션이 적용된 3D 모델을 새로운 3D 파일(예: GLB)로 생성하여 오브젝트 스토리지에 저장.
        *   **고민 사항:** 다양한 3D 모델 스켈레톤 구조에 대한 범용적인 리타겟팅 알고리즘 개발, 모션의 자연스러움과 품질 보장, 고성능 컴퓨팅 자원 활용.
    *   **4단계: 적용 결과 실시간 확인 (프론트엔드)**
        1.  모션이 적용된 결과물 3D 파일 로드 (Three.js).
        2.  웹 기반 3D 뷰어에서 모션이 적용된 모델을 실시간으로 렌더링하고 재생.
        *   **고민 사항:** 대용량 3D 모델 및 모션 데이터의 웹 환경에서의 효율적인 로딩 및 렌더링 성능 최적화.
### 3.4. 모션 편집 도구
*   **기술:** Three.js, React (UI 컴포넌트), WebGL
*   **활용 방안:**
    *   **파라미터 조정:** 3D 뷰어와 연동된 UI 컨트롤(슬라이더, 입력 필드)을 통해 모션의 속도, 스케일, 특정 관절의 회전/위치 등을 실시간으로 조정.
    *   **시각적 피드백:** 조정된 파라미터가 3D 뷰어에 즉시 반영되어 시각적인 피드백 제공.

### 3.5. 결과물 내보내기
*   **기술:** Three.js (GLTFExporter 등), 백엔드 파일 처리
*   **활용 방안:**
    *   **파일 변환:** 모션이 적용된 3D 모델을 클라이언트 또는 서버 측에서 GLB, FBX 등 다양한 3D 파일 형식으로 변환.
    *   **다운로드:** 변환된 파일을 사용자에게 제공하여 다운로드.

### 3.6. 사용자 및 프로젝트 대시보드
*   **기술:** 프론트엔드 (React), 백엔드 (Spring Boot), 데이터베이스 (MySQL)
*   **활용 방안:**
    *   **데이터 연동:** 백엔드 API를 통해 사용자 정보, 업로드 모델 목록, 프로젝트 목록, 모션 적용 기록 등을 조회 및 관리.
    *   **UI 구현:** React 컴포넌트를 활용하여 직관적인 대시보드 UI 구현.

## 4. 데이터베이스 설계
*   **User:** 사용자 계정 정보 (ID, 이메일, 비밀번호(해싱), 이름 등)
    *   **Model:** 업로드된 3D 모델 정보 (ID, 사용자 ID, 파일 경로(오브젝트 스토리지), 모델명, 형식, 크기, 메타데이터 등)
    *   **Motion:** 모션 데이터 정보 (ID, 모션 파일 경로, 모션명, 형식, 길이, 태그, 카테고리 등)
    *   **Project:** 사용자 프로젝트 정보 (ID, 사용자 ID, 프로젝트명, 설명, 포함된 모델/모션 목록 등)
*   관계 및 속성:
    *   User는 여러 Model, Motion, Project를 소유할 수 있음 (1:N 관계).
    *   Project는 여러 Model과 Motion을 포함할 수 있음 (N:M 관계).
    *   각 엔티티는 고유 ID를 가지며, 생성/수정 일시 등 공통 속성 포함.
    *   (상세 스키마는 별도 ERD 문서 참조)

## 5. API 명세
*   주요 API 엔드포인트 목록:
    *   **인증/인가:**
        *   `POST /api/auth/signup`: 회원가입
        *   `POST /api/auth/login`: 로그인
        *   `POST /api/auth/logout`: 로그아웃
    *   **3D 모델 관리:**
        *   `POST /api/models`: 3D 모델 업로드
        *   `GET /api/models`: 사용자 모델 목록 조회
        *   `GET /api/models/{id}`: 특정 모델 상세 조회
        *   `PUT /api/models/{id}`: 모델 정보 수정
        *   `DELETE /api/models/{id}`: 모델 삭제
    *   **모션 라이브러리:**
        *   `GET /api/motions`: 모션 라이브러리 검색/필터링
        *   `GET /api/motions/{id}`: 특정 모션 상세 조회
    *   **모션 적용/편집:**
        *   `POST /api/motions/apply`: 3D 모델에 모션 적용 요청
        *   `GET /api/motions/apply/{id}/status`: 모션 적용 진행 상태 조회
        *   `PUT /api/motions/apply/{id}/edit`: 적용된 모션 편집 (파라미터 조정)
    *   **결과물 내보내기:**
        *   `GET /api/results/{id}/download`: 모션 적용 결과물 다운로드
    *   **프로젝트 관리:**
        *   `POST /api/projects`: 새 프로젝트 생성
        *   `GET /api/projects`: 사용자 프로젝트 목록 조회
        *   `PUT /api/projects/{id}`: 프로젝트 정보 수정
        *   `DELETE /api/projects/{id}`: 프로젝트 삭제
*   요청/응답 형식 예시:
    *   **회원가입 요청 (POST /api/auth/signup):**
        ```json
        {
          "email": "user@example.com",
          "password": "password123",
          "username": "game_dev"
        }
        ```
    *   **모션 적용 요청 (POST /api/motions/apply):**
        ```json
        {
          "modelId": "model_uuid_123",
          "motionId": "motion_uuid_456",
          "parameters": {
            "speed": 1.0,
            "scale": 1.0
          }
        }
        ```
    *   (상세 명세는 별도 API 문서 참조)

## 6. 배포 및 운영 방안
*   클라우드 플랫폼: AWS 또는 GCP와 같은 주요 클라우드 서비스 제공자를 활용하여 인프라를 구축합니다.
    *   **프론트엔드:** S3 (또는 Cloud Storage)에 정적 웹사이트 호스팅, CloudFront (또는 Cloud CDN)를 통한 CDN 구성.
    *   **백엔드:** EC2 (또는 Compute Engine) 인스턴스 또는 컨테이너 서비스 (ECS/EKS 또는 GKE)에 Spring Boot 애플리케이션 배포.
    *   **데이터베이스:** RDS (MySQL) 또는 Cloud SQL (MySQL)과 같은 관리형 데이터베이스 서비스 사용.
    *   **오브젝트 스토리지:** S3 또는 Cloud Storage를 사용하여 대용량 3D 모델 및 모션 파일 저장.
*   CI/CD 파이프라인: GitHub Actions, Jenkins, GitLab CI/CD 등을 활용하여 코드 변경 시 자동화된 테스트, 빌드, 배포 프로세스를 구축합니다.
    *   코드 커밋 -> 자동 테스트 -> 빌드 -> 컨테이너 이미지 생성 (Docker) -> 컨테이너 레지스트리 푸시 -> 배포 환경 업데이트.

## 7. 보안 고려사항
*   인증/인가: JWT(JSON Web Token) 기반의 사용자 인증 및 세션 관리 구현. 역할 기반 접근 제어(RBAC)를 통해 사용자 유형별(일반 사용자, 관리자) 기능 및 데이터 접근 권한을 세분화합니다.
*   데이터 암호화: 민감한 사용자 정보(비밀번호 등)는 단방향 해싱(예: bcrypt)을 사용하여 저장하고, DB 저장 데이터 중 민감 정보 필드는 암호화하여 보호합니다. 통신 구간은 모두 HTTPS를 적용하여 데이터 전송 중 암호화를 보장합니다.
*   파일 보안: 업로드된 3D 모델 및 모션 파일은 오브젝트 스토리지에 안전하게 저장하고, 사용자별 접근 권한을 철저히 관리합니다.
*   취약점 관리: XSS, CSRF, SQL Injection 등 웹 애플리케이션 취약점에 대한 방어 로직을 구현하고, 정기적인 보안 취약점 점검 및 패치를 수행합니다.

## 8. 테스트 전략
*   **단위 테스트:** 프론트엔드(React 컴포넌트, 유틸리티 함수) 및 백엔드(서비스 로직, 유틸리티 클래스)의 개별 모듈/함수 단위로 기능을 검증합니다.
*   **통합 테스트:** 프론트엔드-백엔드 API 연동, 데이터베이스 연동, 3D 처리 모듈 연동 등 시스템 구성 요소 간의 상호작용을 검증합니다.
*   **시스템 테스트:** 전체 시스템의 기능 및 비기능 요구사항(성능, 보안 등) 충족 여부를 사용자 시나리오 기반으로 검증합니다.
*   **3D 관련 테스트:**
    *   **3D 뷰어 기능 테스트:** 3D 모델 렌더링 정확성, 모션 재생 성능, 뷰어 컨트롤 동작 등을 검증합니다.
    *   **모션 적용 로직 테스트:** 다양한 3D 모델 및 모션 파일에 대한 적용 정확성, 호환성, 변환 결과의 유효성을 검증합니다.
*   **성능 테스트:** 동시 사용자 부하 테스트, 대용량 파일 처리 성능 테스트 등을 통해 시스템의 성능 요구사항 충족 여부를 확인합니다.
*   **보안 테스트:** 인증/인가, 데이터 접근 제어, 웹 취약점(XSS, CSRF 등)에 대한 보안 테스트를 수행합니다.
